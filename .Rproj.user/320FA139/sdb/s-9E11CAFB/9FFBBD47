{
    "contents" : "source(\"../handshake_9_11/model/GloableConvert.R\")\nlibrary(zoo)\n\nlowFilter = function(mdata,n = 3){\n  # rollapply(mdata,n,mean)\n  bf = butter(1, 1/8)\n  b <- filter(bf, mdata)\n  b[1:20] = mdata[1:20]\n  return(b)\n}\n\ngetInitMatrix = function(data) {\n  lx = data$LinearAcc0; ly = data$LinearAcc1; lz = data$LinearAcc2;\n  gx = data$Gravity0; gy = data$Gravity1; gz = data$Gravity2;\n  linearAcc = c(lx,ly,lz); gravity = c(gx, gy, gz)\n  gravity = unitVector(gravity)\n  axis2 = product(linearAcc, gravity)\n  axis2 = unitVector(axis2) #left right\n  axis3 = product(axis2, gravity) #forward back\n  axis3 = unitVector(axis3)\n  initMatrix = matrix(\n    c(\n      axis2[1],axis2[2],axis2[3],\n      axis3[1],axis3[2],axis3[3],\n      gravity[1],gravity[2],gravity[3]\n    ),\n    nrow = 3,ncol = 3\n  )\n  return (initMatrix)\n}\n\nconvertBaseOnFt = function(data) {\n  gyrs = cbind(data$Gyro0, data$Gyro1, data$Gyro2)\n  initMatrix = getInitMatrix(data[1,])\n  rtms = updateMatrixByMultiGYR(gyrs, initMatrix, 0.02)\n  accs = cbind(data$LinearAcc0, data$LinearAcc1, data$LinearAcc2)\n  globalAccs = getGlobleAccs(accs, rtms)\n  k = data.frame()\n  for(i in 1:nrow(globalAccs)){\n    k = rbind(k,unitVector(as.numeric(globalAccs[i,])))\n  }\n  return(k)\n}\n\nunitVector = function(vector) {\n  absVector  = norm(matrix(vector),type = \"2\")\n  if(absVector == 0) return (vector)\n  return(vector / absVector)\n}\n\nreadData = function(fileHead,fileTag,fileEnd, start, end) {\n  file = paste(fileHead,fileTag,fileEnd, sep = \"\")\n  data = read.csv(file,colClasses = rep(\"numeric\"))\n  data = data[start:end,]\n  return(data)\n}\n\nabsVector = function(v1, v2, v3) {\n  return(sqrt(v1 ^ 2 + v2 ^ 2 + v3 ^ 2))\n}\n\nnormVector = function(v1, v2, v3) {\n  abs = absVector(v1, v2, v3)\n  return(cbind(v1 / abs, v2 / abs, v3 / abs))\n}\n\ncombineVectors = function (data) {\n  return(sqrt(as.numeric(data[,1]) ^2 +as.numeric(data[,2]) ^2  +as.numeric(data[,3]) ^2 ))\n}\n\nfilterGravity = function(ax, ay, az, len) {\n  gravity = as.double(as.vector(c(ax[1],ay[1],az[1])))\n  #gravity = as.double(as.vector(c(0,0,0)))\n  alpha = 0.8\n  \n  gv1 = as.double(c(1:len))\n  gv2 = as.double(c(1:len))\n  gv3 = as.double(c(1:len))\n  gvectors = data.frame(gv1, gv2, gv3)\n  \n  lv1 = as.double(c(1:len))\n  lv2 = as.double(c(1:len))\n  lv3 = as.double(c(1:len))\n  lvectors = data.frame(lv1, lv2, lv3)\n  \n  for (i in 1:len) {\n    gravity[1] = alpha * gravity[1] + (1 - alpha) * ax[i]\n    gravity[2] = alpha * gravity[2] + (1 - alpha) * ay[i]\n    gravity[3] = alpha * gravity[3] + (1 - alpha) * az[i]\n    \n    gvectors[i, 1] = gravity[1]\n    gvectors[i, 2] = gravity[2]\n    gvectors[i, 3] = gravity[3]\n    \n    lvectors[i, 1] = ax[i] - gravity[1]\n    lvectors[i, 2] = ay[i] - gravity[2]\n    lvectors[i, 3] = az[i] - gravity[3]\n  }\n  return (cbind(gvectors,  lvectors, combineVectors(gvectors)))\n  \n}\n\ncomputeAngle = function(v1, v2){\n  sum = 0\n  for(i in 1:3){\n    sum = sum + v1[i]*v2[i]\n  }\n  cosAngle = sum / (absVector(v1[1],v1[2],v1[3])*absVector(v2[1],v2[2],v2[3]))\n  sign = 1\n  \n  return(sign*acos(cosAngle)*180/pi)\n}\n\ncomputeProjOnGravaty = function(lv, gv) {\n  absProj = ((\n    lv[,1] * gv[1] + lv[,2] * gv[2] + lv[,3] * gv[3]\n  ) /\n    absVector(gv[1], gv[2], gv[3])\n  )\n  \n  nvg = gv/absVector(gv[1],gv[2],gv[3])\n  results = data.frame()\n  for(i in 1:length(absProj)){\n    results = rbind(results,nvg*absProj[i])\n  }\n  return(results)\n}\n\ncomputeProjOnHori = function(lv, gv) {\n  pg = computeProjOnGravaty(lv, gv)\n  return(cbind(lv[,1] - pg[,1],lv[,2] - pg[,2],lv[,3] - pg[,3]))\n}\n\ncomputeProjOnHoriSingleData = function(lv, gv) {\n  absProj = ((\n    lv[1] * gv[1] + lv[2] * gv[2] + lv[3] * gv[3]\n  ) /\n    absVector(gv[1], gv[2], gv[3])\n  )\n  pg = gv/absVector(gv[1],gv[2],gv[3])*absProj\n  return(cbind(lv[1] - pg[1], lv[2] - pg[2], lv[3] - pg[3]))\n}\n\n#PCA proces:\npcaProcess = function(data){\n  epca6A <- prcomp(data,\n                   center = TRUE,\n                   scale. = FALSE)\n  data = predict(epca6A, newdata = data)\n  return(epca6A$rotation[,1])\n}\n\ncone3d <- function(base=c(0,0,0),tip=c(0,0,1),rad=1,n=30,draw.base=TRUE,qmesh=FALSE,\n                   trans = par3d(\"userMatrix\"), ...) {\n  ax <- tip-base\n  if (missing(trans) && !rgl.cur()) trans <- diag(4)\n  ### is there a better way?\n  if (ax[1]!=0) {\n    p1 <- c(-ax[2]/ax[1],1,0)\n    p1 <- p1/sqrt(sum(p1^2))\n    if (p1[1]!=0) {\n      p2 <- c(-p1[2]/p1[1],1,0)\n      p2[3] <- -sum(p2*ax)\n      p2 <- p2/sqrt(sum(p2^2))\n    } else {\n      p2 <- c(0,0,1)\n    }\n  } else if (ax[2]!=0) {\n    p1 <- c(0,-ax[3]/ax[2],1)\n    p1 <- p1/sqrt(sum(p1^2))\n    if (p1[1]!=0) {\n      p2 <- c(0,-p1[3]/p1[2],1)\n      p2[3] <- -sum(p2*ax)\n      p2 <- p2/sqrt(sum(p2^2))\n    } else {\n      p2 <- c(1,0,0)\n    }\n  } else {\n    p1 <- c(0,1,0); p2 <- c(1,0,0)\n  }\n  degvec <- seq(0,2*pi,length=n+1)[-1]\n  ecoord2 <- function(theta) {\n    base+rad*(cos(theta)*p1+sin(theta)*p2)\n  }\n  i <- rbind(1:n,c(2:n,1),rep(n+1,n))\n  v <- cbind(sapply(degvec,ecoord2),tip)\n  if (qmesh) \n    ## minor kluge for quads -- draw tip twice\n    i <- rbind(i,rep(n+1,n))\n  if (draw.base) {\n    v <- cbind(v,base)\n    i.x <- rbind(c(2:n,1),1:n,rep(n+2,n))\n    if (qmesh)  ## add base twice\n      i.x <-  rbind(i.x,rep(n+2,n))\n    i <- cbind(i,i.x)\n  }\n  if (qmesh) v <- rbind(v,rep(1,ncol(v))) ## homogeneous\n  if (!qmesh)\n    triangles3d(v[1,i],v[2,i],v[3,i],...)\n  else\n    return(rotate3d(qmesh3d(v,i,material=...), matrix=trans))\n}     \n\narrows3d = function(v,lim3d = c(-1,1),title=\"3d\"){\n  open3d()\n  data = rbind(c(0,0,0),v)\n  plot3d(data,type = \"l\", col=\"red\", lwd = 5, xlim = lim3d, ylim = lim3d, zlim = lim3d,main  =title, cex.main = 1.5, cex.lab = 1.5,xlab = \"right\",ylab=\"forward\",zlab=\"up\")\n#   vec=rbind( c( 0, 0, 0 ), v )\n#   segments3d( vec )\n#   cone3d(base=vec[2,]-(vec[1,]+vec[2,]/6), \n#          #this makes the head go 1/6th the length of the arrow\n#          rad=0.1,\n#          tip=vec[2,],\n#          col=\"blue\",\n#          front=\"lines\",\n#          back=\"lines\")\n}\n\ncrossProduct = function(a, b){\n  c = rep(0,3)\n  c[1] = a[2]*b[3] - a[3]*b[2]\n  c[2] = a[3]*b[1] - a[1]*b[3]\n  c[3] = a[1]*b[2] - a[2]*b[1]\n  return(c)\n}\n\ndotProduct = function(a,b){\n  return(a[1]*b[1]+a[2]*b[2]+a[3]*b[3])\n}\n\nabsVector1 = function(v){\n  return(sqrt(v[1]^2 + v[2]^2 + v[3]^2))\n}\n\nvectorToMatrix = function(v){\n  return(matrix(v,nrow=3))\n}\n\nmatrixToVector = function(matrixV){\n  return (c(matrixV[1,1],matrixV[2,1],matrixV[3,1]))\n}\n\nrotationByMatrix = function(v, rotationMatrix){\n  temp = rotationMatrix%*%vectorToMatrix(v)\n  return(matrixToVector(temp))\n}\n\ncomputeFi = function(myData) {\n  firstData = myData[1,]\n  gvInit = cbind(firstData$Gravity0,firstData$Gravity1,firstData$Gravity2)\n  mgInit = cbind(firstData$MagnetData0,firstData$MagnetData1,firstData$MagnetData2)\n  initRotationMatirx = getMatrixByMag(gvInit,mgInit)\n  globalAccs = getGlobalAccByMag(myData)\n  globalAccs[,3] = 0; #proj on horizontal\n  matplot(globalAccs,type = \"l\",col = c(1,2,3),main = \"global accs\")\n  rotatedGlobal = c()\n  for (i in 1:nrow(globalAccs)) {\n    temp = initRotationMatirx %*% matrix(globalAccs[i,],nrow = 3,byrow = F)\n    rotatedAcc = c(temp[1,1],temp[2,1],temp[3,1])\n    # rotatedAccOnHori = computeProjOnHoriSingleData(rotatedAcc,gvInit)\n    rotatedGlobal = rbind(rotatedGlobal, rotatedAcc)\n  }\n  return(list(rotatedGlobal,initRotationMatirx))\n}\n\ngetDirection = function(v1,v2, gv){\n  tempV = crossProduct(v1,v2)\n  angle = computeAngle(tempV,gv)\n  if(angle>90) return(-1)\n  else return(1)\n}\n\nsampleByData = function(mdata, step = 2){\n  end = nrow(mdata)\n  return(mdata[seq(1,end,step),])\n}\n",
    "created" : 1458015107296.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2132050167",
    "id" : "9FFBBD47",
    "lastKnownWriteTime" : 1456897710,
    "path" : "~/workspace/R/multidevicealign/utils.R",
    "project_path" : "utils.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "type" : "r_source"
}