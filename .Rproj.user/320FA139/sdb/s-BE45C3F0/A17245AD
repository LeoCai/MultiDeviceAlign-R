{
    "contents" : "source(\"utils.R\")\nsource(\"readData.R\")\nsource(\"getMatrixByMag.R\")\nlibrary(zoo)\nlibrary(signal)\n\n\ngetUpdateMatrix = function(cuMatrix, gyr, dt) {\n  #wait for test\n  delta = sqrt((gyr[1] * dt) ^ 2 + (gyr[2] * dt) ^ 2 + (gyr[3] * dt) ^ 2)\n  B = matrix(\n    c(\n      0,             -gyr[3] * dt,    gyr[2] * dt,\n      gyr[3] * dt,   0,               -gyr[1] * dt,\n      -gyr[2] * dt,  gyr[1] * dt,     0\n    ),\n    nrow = 3, ncol = 3, byrow = TRUE\n  )\n  B1 = B * (sin(delta) / delta)\n  B2 = (1 - cos(delta)) / (delta ^ 2) * (B %*% B)\n  updateMatrix = I + B1 + B2\n  return(cuMatrix%*%updateMatrix)\n}\n\nRotationMatrix = function(angle, u){\n  norm = absVector1(u)\n  u[1] = u[1] / norm; u[2] = u[2] / norm; u[3] = u[3] / norm \n  rotationMatrix = matrix(nrow = 3, ncol = 3)\n  rotationMatrix[1,1] = cos(angle) + u[1]^2*(1-cos(angle))\n  rotationMatrix[1,2] = u[1]*u[2]*(1-cos(angle)) - u[3]*sin(angle)\n  rotationMatrix[1,3] = u[2]*sin(angle) + u[1]*u[3]*(1-cos(angle))\n  \n  rotationMatrix[2,1] = u[3]*sin(angle) + u[1]*u[2]*(1-cos(angle))\n  rotationMatrix[2,2] = cos(angle) + u[2]^2 * (1-cos(angle))\n  rotationMatrix[2,3] = -u[1]*sin(angle) + u[2]*u[3]*(1-cos(angle))\n  \n  rotationMatrix[3,1] = -u[2]*sin(angle) + u[1]*u[3]*(1-cos(angle))\n  rotationMatrix[3,2] = u[1]*sin(angle) + u[2]*u[3]*(1-cos(angle))\n  rotationMatrix[3,3] = cos(angle) + u[3]^2*(1-cos(angle))\n  \n  return(rotationMatrix)\n}\n\ngetCarlibratedMatirx = function(computedInitGV, initRealGV){\n  vectorBefore = computedInitGV; vectorAfter = initRealGV\n  rotationAxis = crossProduct(vectorBefore, vectorAfter)\n  rotationAngle = acos(dotProduct(vectorBefore, vectorAfter) / absVector1(vectorBefore)/absVector1(vectorAfter))\n  rotationAngles <<- c(rotationAngles, rotationAngle/pi*180)\n  # print(paste(\"rotationAngle\",rotationAngle/pi*180))\n  rotationMatrix = RotationMatrix(rotationAngle, rotationAxis)\n  return(rotationMatrix)\n}\n\n# vectorBefore = c(1,3,5); vectorAfter = c(1,1,1)\n# vectorBefore = unitVector(vectorBefore); vectorAfter = unitVector(vectorAfter)\n# rm = getUpdateMatirx2(vectorBefore, vectorAfter)\n# rm%*%matrix(vectorBefore,nrow = 3)\n\n\nmatplot(cbind(top$MagnetData1,lowFilter(top$MagnetData1)),main=\"low pass\",type=\"l\")\n\ngyroConvert = function(mdata,tag = \"\", lowpass=T, gyrpercent = 0.9){\n  rotationAngles <<- c()\n  firstData= mdata[1,]\n  initGV = cbind(firstData$Gravity0,firstData$Gravity1,firstData$Gravity2)\n  initMagV = cbind(firstData$MagnetData0,firstData$MagnetData1,firstData$MagnetData2)\n  initMatric = getMatrixByMag(initGV, initMagV)\n  cuMatrix = initMatric\n  cuMatrixComplementary = initMatric\n  \n  ucbAccs_Gyr = c()\n  ucbAccs_Acc = c()\n  cbAccs_complementary = c()\n  cbAccs = c()\n  globalAccsComplementary = c()\n  \n  if(lowpass){\n    mdata$Gravity0 = lowFilter(mdata$Gravity0)\n    mdata$Gravity1 = lowFilter(mdata$Gravity1)\n    mdata$Gravity2 = lowFilter(mdata$Gravity2)\n  }\n  \n  preAccRoll = atan2(initGV[1], initGV[3])\n  preAccPitch = atan2(initGV[2], initGV[3])\n  preAccYaw = atan2(initGV[1], initGV[2])\n  \n  for(i in 2:nrow(mdata)){\n    sdata = mdata[i,]\n    lacc = cbind(sdata$LinearAcc0,sdata$LinearAcc1,sdata$LinearAcc2)\n    gyr = cbind(sdata$Gyro0, sdata$Gyro1, sdata$Gyro2)\n    gacc = cbind(sdata$Gravity0, sdata$Gravity1, sdata$Gravity2)\n   \n    dt = sdata$dt\n    cuMatrix = getUpdateMatrix(cuMatrix, gyr, dt)\n    unCarliratedGlobalAcc = rotationByMatrix(lacc, cuMatrix)\n    ucbAccs_Gyr = rbind(ucbAccs_Gyr, unCarliratedGlobalAcc)\n    \n    cuAccPitch = atan2(gacc[1], gacc[3]); cuAccRoll = atan2(gacc[2], gacc[3]); cuAccYaw = atan2(gacc[1], gacc[2])\n    accDeltaPitch = cuAccPitch - preAccPitch; accDeltaRoll = cuAccRoll - preAccRoll; accDeltaYaw = cuAccYaw - preAccYaw\n    preAccPitch = cuAccPitch; preAccRoll = cuAccRoll; preAccYaw = cuAccYaw\n    gyrComplementary = cbind(gyrpercent*gyr[1] + (1-gyrpercent)*accDeltaPitch, gyrpercent*gyr[2] + (1-gyrpercent)*accDeltaRoll, gyrpercent*gyr[3]+(1-gyrpercent)*accDeltaYaw)\n    cuMatrixComplementary = getUpdateMatrix(cuMatrixComplementary, gyrComplementary, dt)\n    globalAccComplementary = rotationByMatrix(lacc, cuMatrixComplementary)\n    globalAccsComplementary = rbind(globalAccsComplementary, globalAccComplementary)\n    \n    computedInitGV = rotationByMatrix(gacc, cuMatrix)\n    carlibratedMatrix = getCarlibratedMatirx(rotationByMatrix(initGV,initMatric), computedInitGV)\n    carlibratedGlobalAcc = rotationByMatrix(unCarliratedGlobalAcc, carlibratedMatrix)\n    cbAccs = rbind(cbAccs, carlibratedGlobalAcc)\n    \n    accMatrix = getCarlibratedMatirx(rotationByMatrix(initGV,initMatric), gacc)\n    ucbAccBy_Acc = rotationByMatrix(lacc, accMatrix)\n    ucbAccs_Acc  = rbind(ucbAccs_Acc, ucbAccBy_Acc)\n#     \n    cbAccs_complementary = rbind(cbAccs_complementary,as.vector(unCarliratedGlobalAcc)*0.9 - as.vector(ucbAccBy_Acc)*0.1)\n  }\n  \n  ucbAccs_Gyr = rbind(c(firstData$LinearAcc0,firstData$LinearAcc1,firstData$LinearAcc2),ucbAccs_Gyr)\n  cbAccs  = rbind(c(firstData$LinearAcc0,firstData$LinearAcc1,firstData$LinearAcc2),cbAccs)\n  ucbAccs_Acc = rbind(c(firstData$LinearAcc0,firstData$LinearAcc1,firstData$LinearAcc2),ucbAccs_Acc)\n  cbAccs_complementary = rbind(c(firstData$LinearAcc0,firstData$LinearAcc1,firstData$LinearAcc2),cbAccs_complementary)\n  globalAccsComplementary = rbind(c(firstData$LinearAcc0,firstData$LinearAcc1,firstData$LinearAcc2),globalAccsComplementary)\n  \n  magAccs = getGlobalAccByMag(mdata)\n  \n  cor_uncarlibrated = mean(c(cor(magAccs[,1],ucbAccs_Gyr[,1]),cor(magAccs[,2],ucbAccs_Gyr[,2]),cor(magAccs[,3],ucbAccs_Gyr[,3])))\n  cor_carlibrated = mean(c(cor(magAccs[,1],cbAccs[,1]),cor(magAccs[,2],cbAccs[,2]),cor(magAccs[,3],cbAccs[,3])))\n  \n  matplot(magAccs,type = \"l\" , main = paste(tag,\"magAccs\"),cex.main = 1.5, cex.lab=1.5,ylab = \"magnitude(m/s^2)\")\n  legend(\n    \"topright\",c(\"Right\",\"Forward\",\"Up\"),lty = 1:3, col = 1:3,cex = 1.5\n  )\n  matplot(ucbAccs_Gyr,type = \"l\" , main = paste(tag,\"uncarlibrated Accs Mean-Cor:\",cor_uncarlibrated),cex.main = 1.5, cex.lab=1.5,ylab = \"magnitude(m/s^2)\")\n  legend(\n    \"topright\",c(\"Right\",\"Forward\",\"Up\"),lty = 1:3, col = 1:3,cex = 1.5\n  )\n  matplot(cbAccs,type = \"l\" , main = paste(tag,\"carlibrated Accs Mean-Cor:\",cor_carlibrated),cex.main = 1.5, cex.lab=1.5,ylab = \"magnitude(m/s^2)\")\n  legend(\n    \"topright\",c(\"Right\",\"Forward\",\"Up\"),lty = 1:3, col = 1:3,cex = 1.5\n  )\n  \n  matplot(cbind(magAccs[,2],ucbAccs_Gyr[,2],ucbAccs_Acc[,2],cbAccs_complementary[,2],cbAccs[,2]),type = \"l\",main=paste(tag,\"forward global acc compare\") ,lwd = 1,cex.main=1.5,cex.lab= 1.5)\n  legend(\"topright\",c(\"mag\",\"gyr\",\"acc\",\"complementary\",\"carlibrate\"),col = 1:4, lty=1:4)\n  \n  nrow(magAccs)\n  \n#   print(\"1\")\n#   print(cor(magAccs[,1],ucbAccs_Gyr[,1]))\n#   print(cor(magAccs[,1],cbAccs[,1]))\n#   \n  dimentions = c(\"RIGHT\",\"FORWARD\",\"UP\")\n  for(i in 1:3){\n    print(paste(tag,dimentions[i],\"only by gyroscope    cor:\",cor(magAccs[,i],ucbAccs_Gyr[,i])))\n    print(paste(tag,dimentions[i],\"lowpass\",lowpass, \"only by acc    cor:\",cor(magAccs[,i],ucbAccs_Acc[,i])))\n    print(paste(tag,dimentions[i],\"caribrate by t0    cor:\",cor(magAccs[,i],cbAccs[,i])))\n    print(paste(tag,dimentions[i],\"lowpass\",lowpass,\"complementary    cor:\",cor(magAccs[,i],cbAccs_complementary[,i])))\n    print(paste(tag,dimentions[i],\"lowpass\",lowpass,\"input complementary    cor:\",cor(magAccs[,i],globalAccsComplementary[,i])))\n    \n  }\n \n#   \n#   print(\"3\")\n#   print(cor(magAccs[,3],ucbAccs_Gyr[,3]))\n#   print(cor(magAccs[,3],cbAccs[,3]))\n  plot(rotationAngles,type = \"l\",main = paste(tag,\"angle drift\"), \n       ylab = \"angle drift (in degree)\", cex.main=1.5, cex.lab=1.5)\n}\n\ngyroConvert(top,\"TOP\",T,gyrpercent = 0.90)\ngyroConvert(rightHand,\"RIGHTHAND\",T,gyrpercent = 0.90)\ngyroConvert(leftHand,\"LEFTHAND\",T,gyrpercent = 0.90)\ngyroConvert(leftPants,\"LEFTPANTS\",T,gyrpercent = 0.90)\ngyroConvert(rightPants,\"RIGHTPANTS\",T,gyrpercent = 0.90)\n\n\n\n\n\n",
    "created" : 1456126842594.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1487631861",
    "id" : "A17245AD",
    "lastKnownWriteTime" : 1456384453,
    "path" : "~/workspace/R/multidevicealign/update_gyro.R",
    "project_path" : "update_gyro.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}